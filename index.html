<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interaktive Lernsituation ‚Äì Haus (Hotspots)</title>
  <style>
    :root{ --bg:#0b1020; --panel:#11162a; --text:#eaf0ff; --muted:#a6b0cf; --accent:#7aa2ff; --ring: rgba(122,162,255,.35); --shadow: 0 10px 30px rgba(0,0,0,.35); }
    html,body{height:100%;}
    body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; color:var(--text); background: radial-gradient(1200px 600px at 10% -10%, #15204b 0%, transparent 50%), var(--bg); display:flex; align-items:center; justify-content:center; padding:16px; }
    .app{ width:100%; max-width:980px; }
    .card{ background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); border-radius:18px; box-shadow:var(--shadow); overflow:hidden; }
    .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.06);} 
    .header h1{ font-size:18px; margin:0; }
    .header small{ color:var(--muted); display:block; }
    .header .right{ display:flex; align-items:center; gap:8px; }
    .badge{ display:none; padding:4px 8px; border-radius:999px; background:#1f2a57; border:1px solid rgba(255,255,255,.16); font-size:12px; }
    body.is-admin .badge{ display:inline-block; }
    .admin-btn{ background:#18224a; color:#fff; border:1px solid rgba(255,255,255,.2); border-radius:10px; padding:6px 10px; cursor:pointer; }

    .wrap{ position:relative; width:100%; background:#0f1330; overflow:hidden; }
    .wrap img{ width:100%; height:auto; display:block; aspect-ratio:16/10; object-fit:cover; }
    .overlay{ position:absolute; inset:0; pointer-events:none; z-index:1; }
    .hotspot{ cursor:pointer; }
    .label{ font-size:11px; fill:#fff; paint-order:stroke; stroke:rgba(0,0,0,.45); stroke-width:3px; font-weight:700; }
    .poly-fill{ fill: rgba(122,162,255,.18); pointer-events:all; stroke: var(--accent); stroke-width:.8; filter: drop-shadow(0 2px 6px var(--ring)); }

    .toolbar{ position:relative; z-index:3; display:flex; flex-wrap:wrap; align-items:center; gap:8px; padding:10px 16px; border-top:1px solid rgba(255,255,255,.06); background:rgba(15,19,48,0.9); }
    .toolbar button, .toolbar label, .toolbar select, .toolbar input[type="text"]{ background:#18224a; color:#fff; border:1px solid rgba(255,255,255,.16); border-radius:12px; padding:8px 12px; cursor:pointer; }
    .toolbar select{ padding-right:28px; }
    .toolbar input[type="file"]{ display:none; }

    /* USER-MODUS: Hotspots unsichtbar, aber klickbar */
    body:not(.is-admin) .poly-fill{
      fill: transparent !important;
      fill-opacity: 0 !important;
      stroke: transparent !important;
      stroke-opacity: 0 !important;
      stroke-width: 0 !important;
      filter: none !important;
      -webkit-filter: none !important;
      pointer-events: auto !important; /* Klickbar lassen */
    }
    body:not(.is-admin) .label{ display:none !important; }
    /* Sicherheitsnetz f√ºr tempor√§re Edit-/Mess-Ebenen */
    body:not(.is-admin) #editLayer,
    body:not(.is-admin) #measureLayer{ display:none !important; }

    /* Sichtbarkeit per Admin */
    .admin-only.inline{ display:none !important; }
    body.is-admin .admin-only.inline{ display:inline-block !important; }
    .admin-only.flex{ display:none !important; }
    body.is-admin .admin-only.flex{ display:flex !important; }

    .hint{ padding:8px 16px 14px; color:var(--muted); font-size:13px; }
    .hint code{ background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px; }
    .warn{ color:#ffbaba; }

    /* SLIDE (neue "Folie") */
    .slide{ position:fixed; inset:0; z-index:50; display:grid; grid-template-rows: 1fr auto; background: #0a0f25; transform: translateY(100%); transition: transform .4s ease; }
    .slide.open{ transform: translateY(0); }
    .slide-bg{ position:relative; overflow:hidden; background:#0a0f25; }
    .slide-bg img{ width:100%; height:100%; object-fit:cover; transform-origin: top left; will-change: transform; transition: transform .3s ease; display:block; }
    .slide-content{ background: linear-gradient(180deg, rgba(17,22,42,.96), rgba(17,22,42,.94)); border-top-left-radius:18px; border-top-right-radius:18px; box-shadow:var(--shadow); padding:12px 16px 18px; max-height: 45vh; overflow:auto; }
    .slide-content h2{ margin:0 0 6px; font-size:18px; }
    .slide-content .meta{ color:var(--muted); font-size:12px; margin-bottom:8px; }
    .slide-actions{ position:absolute; top:10px; left:10px; display:flex; gap:8px; z-index:2; }
    .slide-actions button{ background:#18224a; color:#fff; border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:8px 12px; cursor:pointer; }

    @media (min-width: 860px){
      .slide{ grid-template-columns: 1.2fr .8fr; grid-template-rows: 1fr; }
      .slide-content{ border-top-left-radius:0; height:100%; max-height:none; border-left:1px solid rgba(255,255,255,.06); }
    }
  </style>
</head>
<body>
  <div class="app card" role="application" aria-label="Interaktive Bild-Hotspots Lernspiel">
    <div class="header">
      <div style="display:flex; gap:12px; align-items:center;">
        <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M10.25 21v-6h3.5v6h5.25V12.5H21L12 3l-9 9.5h2.25V21z"/></svg>
        <div>
          <h1>Haus erkunden</h1>
          <small>Bereiche werden (nur im Admin) angelegt/bearbeitet. Inhalte im Code; Hintergrund pro Bereich aus Datei.</small>
        </div>
        <span class="badge" id="adminBadge">Admin aktiv</span>
      </div>
      <div class="right">
        <button id="adminBtn" class="admin-btn" aria-pressed="false" title="Admin ein/aus">üîí Admin</button>
      </div>
    </div>

    <div class="wrap">
      <img id="baseImage" src="haus.png" alt="Abbildung eines Hauses" />
      <svg class="overlay" id="overlay" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true"></svg>
    </div>

    <div class="toolbar">
      <label class="admin-only inline"><input type="file" id="imgPicker" accept="image/*" />Eigenes Bild laden</label>
      <button id="toggleLabels" type="button" class="admin-only inline" aria-pressed="false">Labels an/aus</button>
      <button id="shareLink" type="button">Teilen (URL kopieren)</button>

      <button id="startMeasure" type="button" class="admin-only inline">Neuen Bereich aufnehmen</button>
      <div class="measure-group admin-only flex" id="measureGroup">
        <button id="undoPoint" type="button">Punkt zur√ºck</button>
        <button id="savePoly" type="button" disabled>Fertig (speichern)</button>
        <button id="cancelMeasure" type="button">Abbrechen</button>
      </div>

      <select id="hotspotSelect" class="admin-only inline">
        <option value="">Bereich w√§hlen‚Ä¶</option>
      </select>
      <div class="edit-group admin-only flex" id="editGroup" style="display:none; align-items:center; gap:8px;">
        <span id="editLabel">Bearbeite: ‚Äì</span>
        <button id="renameBtn" type="button">Umbenennen</button>
        <button id="startEditBtn" type="button">Punkte bearbeiten</button>
        <button id="addPointBtn" type="button" disabled>Punkt hinzuf√ºgen</button>
        <button id="removePointBtn" type="button" disabled>Letzten Punkt entfernen</button>
        <button id="saveEditBtn" type="button" disabled>√Ñnderungen speichern</button>
        <button id="cancelEditBtn" type="button" disabled>Abbrechen</button>
        <button id="deleteBtn" type="button">L√∂schen</button>
      </div>

      <div class="admin-only flex" id="zoomGroup" title="Zoom f√ºr Folie" style="align-items:center; gap:8px;">
        <span>Zoom</span>
        <input id="zoomSlider" type="range" min="1" max="5" step="0.1" value="2">
        <output id="zoomOut">2.0√ó</output>
      </div>

      <div class="admin-only flex" id="assetsGroup" style="align-items:center; gap:8px;">
        <span>Assets-Pfad</span>
        <input id="assetsBase" type="text" value="assets/areas" placeholder="assets/areas" />
        <button id="saveAssetsBase" type="button">Speichern</button>
      </div>

      <!-- Zentrale Daten ‚Üí Export / Import / Server laden -->
      <div class="admin-only flex" id="dataGroup" style="align-items:center; gap:8px;">
        <button id="serverLoadBtn" type="button" title="hotspots.json vom Server laden">Vom Server laden</button>
        <button id="exportBtn" type="button" title="Hotspots als JSON exportieren">Hotspots exportieren</button>
        <label class="inline" title="Hotspots aus JSON importieren"><input type="file" id="importFile" accept="application/json" />Hotspots importieren</label>
        <span id="activeSetInfo" style="margin-left:auto; opacity:.8;"></span>
      </div>
    </div>

    <div id="storageWarn" class="hint warn" style="display:none"></div>
    <div class="hint">
      <strong>Hinweis:</strong> Pro Bereich optionales Hintergrundbild in <code>assets/areas/&lt;slug&gt;/bg.webp|png|jpg</code>. Inhalte bleiben im Code (per Name verkn√ºpft). Labels sind standardm√§√üig aus. Zentrale Hotspots: <code>data/hotspots.json</code> (oder <code>hotspots-<em>set</em>.json</code> via <code>?set=‚Ä¶</code>).
    </div>
  </div>

  <!-- Neue FOLIE -->
  <section class="slide" id="slide" aria-live="polite" aria-modal="true" role="dialog">
    <div class="slide-actions">
      <button id="backBtn" aria-label="Zur√ºck">‚Üê Zur√ºck</button>
      <button id="nextBgBtn" aria-label="N√§chstes Bild" title="N√§chstes Bild">‚ñ∂ Weiter</button>
    </div>
    <div class="slide-bg">
      <img id="slideImg" alt="Bereichsbild" />
    </div>
    <article class="slide-content">
      <div class="meta" id="slideMeta"></div>
      <h2 id="slideTitle">Titel</h2>
      <div id="slideDesc">Beschreibung</div>
    </article>
  </section>

  <script>
    // ===== Utils =====
    const umlauts = { '√§':'ae','√∂':'oe','√º':'ue','√ü':'ss' };
    function slugify(str){
      return String(str||'')
        .toLowerCase()
        .replace(/[√§√∂√º√ü]/g, m=>umlauts[m])
        .replace(/[^a-z0-9\s-]/g,'')
        .trim()
        .replace(/\s+/g,'-')
        .replace(/-+/g,'-');
    }
    function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
    function canUseLocalStorage(){
      try{ const k='__t'; localStorage.setItem(k,'1'); localStorage.removeItem(k); return true; }catch{ return false; }
    }
    function qs(name){ const u=new URL(location.href); return u.searchParams.get(name); }

    // ===== Inhalte (nur im Code) =====
    const contents = {
      dach: {
        title: 'Dach',
        html: `
          <h3>Informationen</h3>
          <ul>
            <li><strong>Bauart:</strong> Steildach/Satteldach.</li>
            <li><strong>Eindeckung:</strong> Tonziegel oder Betondachsteine.</li>
            <li><strong>W√§rmeschutz:</strong> U‚ÄëWert optimieren; W√§rmebr√ºcken minimieren.</li>
            <li><strong>Aufbau:</strong> Deckung ‚Üí Lattung/Konterlattung ‚Üí Unterspannbahn ‚Üí D√§mmung ‚Üí Dampfbremse ‚Üí Innenbekleidung.</li>
          </ul>
          <h3>Arbeitsauftr√§ge</h3>
          <ol>
            <li>Schichtenaufbau skizzieren und Funktionen beschriften.</li>
            <li>Zwei D√§mmstoffe vergleichen (Œª‚ÄëWert, Montage, Nachhaltigkeit) und Empfehlung formulieren.</li>
            <li>Ziegelanzahl f√ºr 40‚ÄØm¬≤ berechnen (14‚ÄØStk/m¬≤, +5‚ÄØ% Verschnitt).</li>
          </ol>
        `
      } 
    eg: {
        title: 'Erdgeschoss - Projekt Raumteiler',
        html: `
          <h3>Informationen</h3>
          <ul>
            <li><strong>Projektbeschreibung:</strong> Penis.</li>
        `
      }
      // weitere Bereiche hier erg√§nzen: fenster: {...}, tuer: {...}, fassade: {...}
    };

    // ===== Persistente Schl√ºssel =====
    const LS_KEYS = { hotspots: 'hotspots_v1', zoom: 'zoom_v1', assets: 'assets_base_v1' };

    // ===== Hotspots ‚Äì initial aus localStorage =====
    let hotspots = loadHotspots();

    // Labels standardm√§√üig AUS
    let labelsOn = false;
    let measureMode = false;
    let draftPoints = [];
    let tempLayer; // Vorschau-Layer (Mess)

    // Editier-Status
    let selectedIndex = -1;
    let editing = false;
    let editLayer = null;
    let editPoints = [];
    let draggingIdx = -1;
    let addingPoint = false;

    // Admin-Status (Session) & PIN
    const ADMIN_PIN = 'test';
    let isAdmin = sessionStorage.getItem('is_admin') === 'true';

    // Globale Zoom-Kennzahl (√ºber Slider √§nderbar)
    let zoom = loadZoom();

    // Assets
    const assetsBaseInput = document.getElementById('assetsBase');
    const assetsBaseBtn = document.getElementById('saveAssetsBase');
    let assetsBase = loadAssetsBase();
    assetsBaseInput.value = assetsBase;

    // Zentrale Daten (Server/Repo)
    const setParam = qs('set');
    const activeSetName = setParam ? slugify(setParam) : 'default';
    const centralPath = activeSetName === 'default' ? 'data/hotspots.json' : `data/hotspots-${activeSetName}.json`;

    // DOM Refs
    const overlay = document.getElementById('overlay');
    const measureGroup = document.getElementById('measureGroup');
    const startBtn = document.getElementById('startMeasure');
    const undoBtn = document.getElementById('undoPoint');
    const saveBtn = document.getElementById('savePoly');
    const cancelBtn = document.getElementById('cancelMeasure');

    const hotspotSelect = document.getElementById('hotspotSelect');
    const editGroup = document.getElementById('editGroup');
    const editLabel = document.getElementById('editLabel');
    const renameBtn = document.getElementById('renameBtn');
    const startEditBtn = document.getElementById('startEditBtn');
    const addPointBtn = document.getElementById('addPointBtn');
    const removePointBtn = document.getElementById('removePointBtn');
    const saveEditBtn = document.getElementById('saveEditBtn');
    const cancelEditBtn = document.getElementById('cancelEditBtn');
    const deleteBtn = document.getElementById('deleteBtn');

    // Slide elements
    const slide = document.getElementById('slide');
    const slideImg = document.getElementById('slideImg');
    const slideTitle = document.getElementById('slideTitle');
    const slideDesc = document.getElementById('slideDesc');
    const slideMeta = document.getElementById('slideMeta');
    const backBtn = document.getElementById('backBtn');
    const nextBgBtn = document.getElementById('nextBgBtn');

    // Header/Admin
    const adminBtn = document.getElementById('adminBtn');
    const adminBadge = document.getElementById('adminBadge');

    // Data UI
    const serverLoadBtn = document.getElementById('serverLoadBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importFile = document.getElementById('importFile');
    const activeSetInfo = document.getElementById('activeSetInfo');
    activeSetInfo.textContent = `Aktives Set: ${activeSetName} (${centralPath})`;

    // Zoom UI
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomOut = document.getElementById('zoomOut');
    if(zoomSlider){
      zoomSlider.value = String(zoom);
      zoomOut.textContent = `${zoom.toFixed(1)}√ó`;
      zoomSlider.addEventListener('input', ()=>{ 
        zoom = parseFloat(zoomSlider.value); 
        zoomOut.textContent = `${zoom.toFixed(1)}√ó`; 
        saveZoom();
      });
    }

    backBtn.addEventListener('click', ()=> closeSlide());

    // ===== Admin Login/Logout =====
    adminBtn.addEventListener('click', ()=>{
      if(isAdmin){
        if(measureMode) toggleMeasure(false);
        if(editing) exitEditMode(false);
        isAdmin = false; sessionStorage.setItem('is_admin','false');
        applyAdminUI();
        return;
      }
      const pin = prompt('Admin-PIN eingeben:');
      if(pin === ADMIN_PIN){
        isAdmin = true; sessionStorage.setItem('is_admin','true');
        applyAdminUI();
      } else if(pin !== null) {
        alert('Falsche PIN.');
      }
    });

    function applyAdminUI(){
      document.body.classList.toggle('is-admin', isAdmin);
      adminBtn.textContent = isAdmin ? 'üîì Admin' : 'üîí Admin';
      adminBtn.setAttribute('aria-pressed', String(isAdmin));
      adminBadge.style.display = isAdmin ? 'inline-block' : 'none';
      if(!isAdmin){ hotspotSelect.value=''; setSelectedIndex(-1); }
      refreshHotspotSelect();
      updateButtons();
      applyPointerEvents();
    }

    // ===== Render =====
    function renderHotspots(){
      overlay.innerHTML = '';
      for(let i=0;i<hotspots.length;i++){
        const h = hotspots[i];
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','hotspot');
        g.setAttribute('tabindex','0'); g.setAttribute('role','button'); g.setAttribute('aria-label', h.id);

        if(h.shape==='polygon'){
          const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
          poly.setAttribute('points', h.points.map(p=>`${p.x},${p.y}`).join(' '));
          poly.setAttribute('class','poly-fill');
          poly.addEventListener('click', (e)=>{ if(!measureMode && !editing){ e.stopPropagation(); openSlide(h);} });
          poly.addEventListener('dblclick', (e)=>{ if(isAdmin){ e.preventDefault(); setSelectedIndex(i); enterEditMode(); }});
          g.appendChild(poly);

          if(isAdmin && labelsOn){
            const cx = h.points.reduce((a,p)=>a+p.x,0)/h.points.length;
            const cy = h.points.reduce((a,p)=>a+p.y,0)/h.points.length - 1.2;
            const label = document.createElementNS('http://www.w3.org/2000/svg','text');
            label.setAttribute('class','label'); label.setAttribute('x', cx); label.setAttribute('y', cy);
            label.textContent = h.id; g.appendChild(label);
          }
        }
        overlay.appendChild(g);
      }

      if(measureMode){
        tempLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
        tempLayer.setAttribute('id','measureLayer');
        const catcher = document.createElementNS('http://www.w3.org/2000/svg','rect');
        catcher.setAttribute('x','0'); catcher.setAttribute('y','0'); catcher.setAttribute('width','100'); catcher.setAttribute('height','100');
        catcher.setAttribute('fill','transparent'); catcher.style.pointerEvents = 'all';
        catcher.addEventListener('click', onMeasureClick);
        tempLayer.appendChild(catcher);
        overlay.appendChild(tempLayer);
      }

      if(editing){ drawEditOverlay(); }

      applyPointerEvents();
      document.getElementById('toggleLabels')?.setAttribute('aria-pressed', String(labelsOn));
    }

    // ===== Hintergrund ermitteln (ohne fetch, server- & file-Modus tauglich) =====
    function tryLoadImageSequential(urls, onOk, onFail){
      let i = 0; const img = new Image();
      const next = ()=>{
        if(i >= urls.length){ onFail && onFail(); return; }
        img.onload = ()=> onOk(urls[i]);
        img.onerror = ()=>{ i++; next(); };
        img.src = urls[i];
      };
      next();
    }

    function backgroundCandidates(slug){
      return [ `${assetsBase}/${slug}/bg.webp`, `${assetsBase}/${slug}/bg.png`, `${assetsBase}/${slug}/bg.jpg` ];
    }

    // ===== Galerie-Logik f√ºr mehrere Hintergrundbilder =====
    const gallery = { slug:null, index:1, cache:new Map(), hasAny:false };
    function bgUrlFor(slug, i, ext){ const n = i<=1 ? '' : String(i); return `${assetsBase}/${slug}/bg${n}.${ext}`; }
    function findBg(slug, i){
      return new Promise(resolve=>{
        const urls = ['webp','png','jpg'].map(ext=>bgUrlFor(slug,i,ext));
        tryLoadImageSequential(urls, url=>resolve(url), ()=>resolve(null));
      });
    }
    async function showIndex(i){
      if(!gallery.slug) return false;
      let url = gallery.cache.get(i);
      if(!url){ url = await findBg(gallery.slug, i); if(url) gallery.cache.set(i, url); }
      if(url){
        slideImg.src = url;
        slideImg.style.transform = 'none';
        slideMeta.textContent = `Bild ${i}`;
        gallery.index = i;
        return true;
      }
      return false;
    }
    function setNavVisible(v){ nextBgBtn.style.display = v ? 'inline-block' : 'none'; }

    // ===== Neue Folie (Slide) =====
    function openSlide(h){
      const id = slugify(h.id||'');

      // Inhalte aus Code
      const c = contents[id];
      slideTitle.textContent = c?.title || h.id || id;
      slideDesc.innerHTML = c?.html || `<p>F√ºr den Bereich <strong>${h.id}</strong> ist noch kein Inhalt hinterlegt.</p>`;

      // Reset Galerie-Status
      gallery.slug = null; gallery.index = 1; gallery.cache = new Map(); gallery.hasAny = false; setNavVisible(false);

      // Hintergrund: erst bereichsspezifisch, sonst gezoomtes Hausbild
      tryLoadImageSequential(backgroundCandidates(id), async (url)=>{
        // eigenes Bild nur im Bildbereich
        slideImg.src = url; 
        slideImg.style.transform = 'none';
        slideMeta.textContent = 'Bild 1';
        slide.classList.add('open');

        // Galerie aktivieren
        gallery.slug = id; gallery.index = 1; gallery.cache.set(1, url); gallery.hasAny = true; setNavVisible(true);
      }, ()=>{
        // Fallback auf Hausbild + Zoom
        const baseSrc = document.getElementById('baseImage').src;
        slideImg.src = baseSrc;
        const cx = h.points.reduce((a,p)=>a+p.x,0)/h.points.length;
        const cy = h.points.reduce((a,p)=>a+p.y,0)/h.points.length;
        const s = Math.max(1, zoom);
        const maxShift = 100 - (100/s);
        const tx = clamp(cx - 50/s, 0, Math.max(0, maxShift));
        const ty = clamp(cy - 50/s, 0, Math.max(0, maxShift));
        slideImg.style.transformOrigin = 'top left';
        slideImg.style.transform = `translate(-${tx}%, -${ty}%) scale(${s})`;
        slideMeta.textContent = `Zoom ${s.toFixed(1)}√ó`;
        slide.classList.add('open');

        // Keine Galerie verf√ºgbar
        setNavVisible(false);
      });

      // Klasse f√ºr bereichsspezifische Styles
      slide.classList.forEach(c=>{ if(c.startsWith('area--')) slide.classList.remove(c); });
      slide.classList.add(`area--${id}`);
    }

    function closeSlide(){
      slide.classList.remove('open');
      slideImg.style.transform = 'none';
    }

    // N√§chstes Bild in der Galerie
    nextBgBtn.addEventListener('click', async ()=>{
      if(!gallery.hasAny) return;
      const next = gallery.index + 1;
      // Bei Erfolg weiter, sonst zur√ºck zu 1 (falls nur ein Bild existiert)
      if(!(await showIndex(next))){ await showIndex(1); }
    });

    // ===== Toolbar =====
    document.getElementById('toggleLabels').addEventListener('click', ()=>{
      labelsOn = !labelsOn; renderHotspots();
      document.getElementById('toggleLabels').setAttribute('aria-pressed', String(labelsOn));
    });
    document.getElementById('shareLink').addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(location.href); alert('Link kopiert!'); } catch{ prompt('Kopiere den Link:', location.href); }
    });
    document.getElementById('imgPicker')?.addEventListener('change', (e)=>{
      const f = e.target.files?.[0]; if(!f) return; document.getElementById('baseImage').src = URL.createObjectURL(f);
    });

    // Assets-Pfad speichern
    assetsBaseBtn.addEventListener('click', ()=>{
      assetsBase = assetsBaseInput.value.trim() || 'assets/areas';
      saveAssetsBase(assetsBase);
      alert('Assets-Pfad gespeichert: '+assetsBase);
    });

    // ===== Mess-Tool Logik (nur Admin sichtbar) =====
    startBtn.addEventListener('click', ()=>{ if(isAdmin) toggleMeasure(true); });
    cancelBtn.addEventListener('click', ()=>{ toggleMeasure(false); });
    undoBtn.addEventListener('click', ()=>{ if(draftPoints.length){ draftPoints.pop(); drawDraft(); updateButtons(); }});
    saveBtn.addEventListener('click', ()=>{
      if(draftPoints.length<3) return;
      let id = prompt('Name (z.‚ÄØB. "dach")','dach');
      if(!id){ alert('Kein Name vergeben. Abgebrochen.'); return; }
      id = slugify(id);
      hotspots.push({ id, shape:'polygon', points:[...draftPoints] });
      saveHotspots();
      toggleMeasure(false);
      refreshHotspotSelect();
      renderHotspots();
    });

    function toggleMeasure(on){
      if(!isAdmin && on) return;
      if(editing && on) exitEditMode(false);
      measureMode = !!on; draftPoints = []; updateButtons(); renderHotspots();
    }
    function updateButtons(){
      measureGroup.classList.toggle('show', measureMode && isAdmin);
      startBtn.style.display = (!isAdmin || measureMode) ? 'none' : 'inline-block';
      saveBtn.disabled = draftPoints.length < 3;

      const showEditGroup = isAdmin && selectedIndex >= 0 && !measureMode;
      editGroup.style.display = showEditGroup ? 'flex' : 'none';
      const hasEdit = editing;
      addPointBtn.disabled = !hasEdit;
      removePointBtn.disabled = !hasEdit || editPoints.length < 1;
      saveEditBtn.disabled = !hasEdit;
      cancelEditBtn.disabled = !hasEdit;
    }

    function onMeasureClick(ev){
      const rect = overlay.getBoundingClientRect();
      const x = +(((ev.clientX - rect.left) / rect.width) * 100).toFixed(1);
      const y = +(((ev.clientY - rect.top) / rect.height) * 100).toFixed(1);
      draftPoints.push({x,y});
      drawDraft();
      updateButtons();
    }

    function drawDraft(){
      while(tempLayer && tempLayer.childNodes.length>1){ tempLayer.removeChild(tempLayer.lastChild); }
      if(!tempLayer) return;
      for(const p of draftPoints){
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r', 0.8); c.setAttribute('fill','#fff');
        tempLayer.appendChild(c);
      }
      if(draftPoints.length>=2){
        const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline');
        pl.setAttribute('points', draftPoints.map(p=>`${p.x},${p.y}`).join(' '));
        pl.setAttribute('class','edit-poly');
        tempLayer.appendChild(pl);
      }
    }

    // ===== Auswahl & Edit =====
    hotspotSelect.addEventListener('change', ()=>{
      const idx = parseInt(hotspotSelect.value,10);
      setSelectedIndex(isNaN(idx) ? -1 : idx);
    });

    renameBtn.addEventListener('click', ()=>{
      if(selectedIndex<0) return;
      const cur = hotspots[selectedIndex].id;
      let id = prompt('Neuer Name f√ºr den Bereich:', cur);
      if(!id) return;
      id = slugify(id);
      hotspots[selectedIndex].id = id;
      saveHotspots();
      refreshHotspotSelect();
      renderHotspots();
      updateEditLabel();
    });

    startEditBtn.addEventListener('click', ()=>{ enterEditMode(); });
    addPointBtn.addEventListener('click', ()=>{ if(!editing) return; addingPoint = true; ensureEditCatcher(); });
    removePointBtn.addEventListener('click', ()=>{ if(!editing) return; editPoints.pop(); drawEditOverlay(); updateButtons(); });
    saveEditBtn.addEventListener('click', ()=>{ if(!editing) return; hotspots[selectedIndex].points = [...editPoints]; saveHotspots(); exitEditMode(true); renderHotspots(); });
    cancelEditBtn.addEventListener('click', ()=>{ exitEditMode(false); });

    deleteBtn.addEventListener('click', ()=>{
      if(selectedIndex<0) return;
      if(!confirm('Diesen Bereich wirklich l√∂schen?')) return;
      hotspots.splice(selectedIndex,1);
      saveHotspots();
      setSelectedIndex(-1);
      refreshHotspotSelect();
      renderHotspots();
    });

    function setSelectedIndex(idx){
      if(editing) exitEditMode(false);
      selectedIndex = idx;
      if(idx>=0){ hotspotSelect.value = String(idx); }
      else { hotspotSelect.value = ''; }
      updateEditLabel();
      updateButtons();
    }

    function updateEditLabel(){
      editLabel.textContent = selectedIndex>=0 ? `Bearbeite: ${hotspots[selectedIndex].id}` : 'Bearbeite: ‚Äì';
    }

    function refreshHotspotSelect(){
      while(hotspotSelect.options.length>1){ hotspotSelect.remove(1); }
      hotspots.forEach((h, i)=>{
        const opt = document.createElement('option');
        opt.value = String(i); opt.textContent = `${h.id} (#${i+1})`;
        hotspotSelect.appendChild(opt);
      });
    }

    function enterEditMode(){
      if(!isAdmin || selectedIndex<0) return;
      if(measureMode) toggleMeasure(false);
      editing = true; addingPoint = false; editPoints = JSON.parse(JSON.stringify(hotspots[selectedIndex].points || []));
      drawEditOverlay();
      updateButtons();
    }

    function exitEditMode(save){
      editing = false; addingPoint = false; editPoints = []; removeEditOverlay();
      updateButtons(); applyPointerEvents();
    }

    function drawEditOverlay(){
      removeEditOverlay();
      editLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
      editLayer.setAttribute('id','editLayer'); editLayer.style.pointerEvents = 'all';

      if(editPoints.length>=2){
        const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline');
        pl.setAttribute('points', editPoints.map(p=>`${p.x},${p.y}`).join(' '));
        pl.setAttribute('class','edit-poly');
        editLayer.appendChild(pl);
      }

      editPoints.forEach((p, idx)=>{
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('class','handle');
        c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r', 1.1);
        c.addEventListener('mousedown', (e)=> startDrag(e, idx));
        c.addEventListener('touchstart', (e)=> startDrag(e, idx));
        editLayer.appendChild(c);
      });

      if(addingPoint){ ensureEditCatcher(); }

      overlay.appendChild(editLayer);
      applyPointerEvents();
    }

    function ensureEditCatcher(){
      const exists = editLayer && editLayer.querySelector('rect[data-catcher="1"]');
      if(exists) return;
      const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('x','0'); r.setAttribute('y','0'); r.setAttribute('width','100'); r.setAttribute('height','100');
      r.setAttribute('fill','transparent'); r.style.pointerEvents = 'all'; r.setAttribute('data-catcher','1');
      r.addEventListener('click', (ev)=>{
        if(!addingPoint) return;
        const rect = overlay.getBoundingClientRect();
        const x = +(((ev.clientX - rect.left) / rect.width) * 100).toFixed(1);
        const y = +(((ev.clientY - rect.top) / rect.height) * 100).toFixed(1);
        editPoints.push({x,y}); addingPoint = false; drawEditOverlay(); updateButtons();
      });
      editLayer.insertBefore(r, editLayer.firstChild);
    }

    function removeEditOverlay(){ if(editLayer){ editLayer.remove(); editLayer = null; } }

    function startDrag(e, idx){
      e.preventDefault(); draggingIdx = idx;
      const move = (ev)=>{
        const pt = getEventXY(ev);
        if(!pt) return; editPoints[draggingIdx] = pt; drawEditOverlay();
      };
      const up = ()=>{
        draggingIdx = -1; window.removeEventListener('mousemove', move); window.removeEventListener('touchmove', move); window.removeEventListener('mouseup', up); window.removeEventListener('touchend', up);
      };
      window.addEventListener('mousemove', move); window.addEventListener('touchmove', move, {passive:false});
      window.addEventListener('mouseup', up); window.addEventListener('touchend', up);
    }

    function getEventXY(ev){
      const rect = overlay.getBoundingClientRect();
      let clientX, clientY;
      if(ev.touches && ev.touches[0]){ clientX = ev.touches[0].clientX; clientY = ev.touches[0].clientY; ev.preventDefault(); }
      else { clientX = ev.clientX; clientY = ev.clientY; }
      const x = +(((clientX - rect.left) / rect.width) * 100).toFixed(1);
      const y = +(((clientY - rect.top) / rect.height) * 100).toFixed(1);
      return { x: clamp(x, 0, 100), y: clamp(y, 0, 100) };
    }

    function applyPointerEvents(){
      // Hotspots sollen immer anklickbar sein ‚Äì auch ohne Admin.
      overlay.style.pointerEvents = 'auto';
    }

    // ===== Persistenz (local) =====
    function loadHotspots(){
      try{ const raw = localStorage.getItem(LS_KEYS.hotspots); return raw ? JSON.parse(raw) : []; }catch{ return []; }
    }
    function saveHotspots(){
      try{ localStorage.setItem(LS_KEYS.hotspots, JSON.stringify(hotspots)); }catch{}
    }
    function loadZoom(){
      const v = parseFloat(localStorage.getItem(LS_KEYS.zoom));
      return isNaN(v) ? 2.0 : v;
    }
    function saveZoom(){
      try{ localStorage.setItem(LS_KEYS.zoom, String(zoom)); }catch{}
    }
    function loadAssetsBase(){ return localStorage.getItem(LS_KEYS.assets) || 'assets/areas'; }
    function saveAssetsBase(base){ try{ localStorage.setItem(LS_KEYS.assets, base); }catch{} }

    // ===== Zentrale Daten (Server) =====
    async function fetchCentralHotspots(showAlerts=true){
      try{
        const url = `${centralPath}?v=${Date.now()}`; // Cache-Bust
        const res = await fetch(url, { cache: 'no-cache' });
        if(!res.ok){ if(showAlerts) alert('Konnte zentrale Datei nicht laden: '+centralPath); return; }
        const json = await res.json();
        if(!Array.isArray(json.hotspots)) { if(showAlerts) alert('Ung√ºltige Datei: Feld "hotspots" fehlt.'); return; }
        hotspots = json.hotspots;
        saveHotspots();
        if(typeof json.zoom === 'number'){ zoom = json.zoom; saveZoom(); if(zoomSlider){ zoomSlider.value = String(zoom); zoomOut.textContent = `${zoom.toFixed(1)}√ó`; } }
        refreshHotspotSelect();
        renderHotspots();
        if(showAlerts) alert('Hotspots vom Server geladen.');
      }catch(err){
        if(showAlerts) alert('Fehler beim Laden der zentralen Hotspots.');
        console.error(err);
      }
    }

    function exportHotspots(){
      const payload = { version:1, updated:new Date().toISOString(), zoom, hotspots };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `hotspots-${activeSetName}-${ts}.json`;
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    function handleImportFile(file){
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const json = JSON.parse(reader.result);
          if(!Array.isArray(json.hotspots)) { alert('Ung√ºltige Datei: "hotspots" fehlt.'); return; }
          hotspots = json.hotspots;
          saveHotspots();
          if(typeof json.zoom === 'number'){ zoom = json.zoom; saveZoom(); if(zoomSlider){ zoomSlider.value = String(zoom); zoomOut.textContent = `${zoom.toFixed(1)}√ó`; } }
          refreshHotspotSelect();
          renderHotspots();
          alert('Hotspots importiert.');
        }catch(e){ alert('Konnte Datei nicht lesen.'); }
      };
      reader.readAsText(file, 'utf-8');
    }

    // ===== Events f√ºr zentrale Daten =====
    serverLoadBtn.addEventListener('click', ()=> fetchCentralHotspots(true));
    exportBtn.addEventListener('click', ()=> exportHotspots());
    importFile.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; if(f) handleImportFile(f); e.target.value=''; });

    // ===== Init =====
    (function init(){
      applyAdminUI();
      refreshHotspotSelect();
      renderHotspots();

      // Sichtbare Warnung, wenn localStorage nicht verf√ºgbar (Privatmodus etc.)
      if(!canUseLocalStorage()){
        const w = document.getElementById('storageWarn');
        w.textContent = 'Achtung: Lokaler Speicher ist deaktiviert (Privatmodus/In‚ÄëApp‚ÄëBrowser). √Ñnderungen werden nicht dauerhaft gespeichert. Nutze "Hotspots exportieren"/"Vom Server laden".';
        w.style.display = 'block';
      }

      // Automatisch vom Server laden, wenn lokal noch nichts vorhanden
      if(!hotspots || hotspots.length === 0){ fetchCentralHotspots(false); }

      // Galerie-Button initial verstecken
      setNavVisible(false);
    })();
  </script>
</body>
</html>
